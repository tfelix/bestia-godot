// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: default.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_default_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_default_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "messages/account.pb.h"
#include "messages/inventory.pb.h"
#include "messages/component.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_default_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_default_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_default_2eproto;
namespace bestia {
namespace messages {
class Wrapper;
class WrapperDefaultTypeInternal;
extern WrapperDefaultTypeInternal _Wrapper_default_instance_;
}  // namespace messages
}  // namespace bestia
PROTOBUF_NAMESPACE_OPEN
template<> ::bestia::messages::Wrapper* Arena::CreateMaybeMessage<::bestia::messages::Wrapper>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bestia {
namespace messages {

// ===================================================================

class Wrapper PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bestia.messages.Wrapper) */ {
 public:
  inline Wrapper() : Wrapper(nullptr) {};
  virtual ~Wrapper();

  Wrapper(const Wrapper& from);
  Wrapper(Wrapper&& from) noexcept
    : Wrapper() {
    *this = ::std::move(from);
  }

  inline Wrapper& operator=(const Wrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wrapper& operator=(Wrapper&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Wrapper& default_instance();

  enum PayloadCase {
    kAuth = 1,
    kAccountVarRequest = 2,
    kAccountVarResponse = 3,
    kCmdUseItem = 100,
    kCmdDropItem = 101,
    kCmdPickupItem = 102,
    kCompPosition = 300,
    kCompTemperature = 301,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Wrapper* internal_default_instance() {
    return reinterpret_cast<const Wrapper*>(
               &_Wrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Wrapper& a, Wrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(Wrapper* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Wrapper* New() const final {
    return CreateMaybeMessage<Wrapper>(nullptr);
  }

  Wrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Wrapper>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Wrapper& from);
  void MergeFrom(const Wrapper& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wrapper* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bestia.messages.Wrapper";
  }
  protected:
  explicit Wrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_default_2eproto);
    return ::descriptor_table_default_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthFieldNumber = 1,
    kAccountVarRequestFieldNumber = 2,
    kAccountVarResponseFieldNumber = 3,
    kCmdUseItemFieldNumber = 100,
    kCmdDropItemFieldNumber = 101,
    kCmdPickupItemFieldNumber = 102,
    kCompPositionFieldNumber = 300,
    kCompTemperatureFieldNumber = 301,
  };
  // .bestia.messages.Auth auth = 1;
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::bestia::messages::Auth& auth() const;
  ::bestia::messages::Auth* release_auth();
  ::bestia::messages::Auth* mutable_auth();
  void set_allocated_auth(::bestia::messages::Auth* auth);
  private:
  const ::bestia::messages::Auth& _internal_auth() const;
  ::bestia::messages::Auth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::bestia::messages::Auth* auth);
  ::bestia::messages::Auth* unsafe_arena_release_auth();

  // .bestia.messages.AccountVarRequest account_var_request = 2;
  bool has_account_var_request() const;
  private:
  bool _internal_has_account_var_request() const;
  public:
  void clear_account_var_request();
  const ::bestia::messages::AccountVarRequest& account_var_request() const;
  ::bestia::messages::AccountVarRequest* release_account_var_request();
  ::bestia::messages::AccountVarRequest* mutable_account_var_request();
  void set_allocated_account_var_request(::bestia::messages::AccountVarRequest* account_var_request);
  private:
  const ::bestia::messages::AccountVarRequest& _internal_account_var_request() const;
  ::bestia::messages::AccountVarRequest* _internal_mutable_account_var_request();
  public:
  void unsafe_arena_set_allocated_account_var_request(
      ::bestia::messages::AccountVarRequest* account_var_request);
  ::bestia::messages::AccountVarRequest* unsafe_arena_release_account_var_request();

  // .bestia.messages.AccountVarResponse account_var_response = 3;
  bool has_account_var_response() const;
  private:
  bool _internal_has_account_var_response() const;
  public:
  void clear_account_var_response();
  const ::bestia::messages::AccountVarResponse& account_var_response() const;
  ::bestia::messages::AccountVarResponse* release_account_var_response();
  ::bestia::messages::AccountVarResponse* mutable_account_var_response();
  void set_allocated_account_var_response(::bestia::messages::AccountVarResponse* account_var_response);
  private:
  const ::bestia::messages::AccountVarResponse& _internal_account_var_response() const;
  ::bestia::messages::AccountVarResponse* _internal_mutable_account_var_response();
  public:
  void unsafe_arena_set_allocated_account_var_response(
      ::bestia::messages::AccountVarResponse* account_var_response);
  ::bestia::messages::AccountVarResponse* unsafe_arena_release_account_var_response();

  // .bestia.messages.UseItem cmd_use_item = 100;
  bool has_cmd_use_item() const;
  private:
  bool _internal_has_cmd_use_item() const;
  public:
  void clear_cmd_use_item();
  const ::bestia::messages::UseItem& cmd_use_item() const;
  ::bestia::messages::UseItem* release_cmd_use_item();
  ::bestia::messages::UseItem* mutable_cmd_use_item();
  void set_allocated_cmd_use_item(::bestia::messages::UseItem* cmd_use_item);
  private:
  const ::bestia::messages::UseItem& _internal_cmd_use_item() const;
  ::bestia::messages::UseItem* _internal_mutable_cmd_use_item();
  public:
  void unsafe_arena_set_allocated_cmd_use_item(
      ::bestia::messages::UseItem* cmd_use_item);
  ::bestia::messages::UseItem* unsafe_arena_release_cmd_use_item();

  // .bestia.messages.DropItem cmd_drop_item = 101;
  bool has_cmd_drop_item() const;
  private:
  bool _internal_has_cmd_drop_item() const;
  public:
  void clear_cmd_drop_item();
  const ::bestia::messages::DropItem& cmd_drop_item() const;
  ::bestia::messages::DropItem* release_cmd_drop_item();
  ::bestia::messages::DropItem* mutable_cmd_drop_item();
  void set_allocated_cmd_drop_item(::bestia::messages::DropItem* cmd_drop_item);
  private:
  const ::bestia::messages::DropItem& _internal_cmd_drop_item() const;
  ::bestia::messages::DropItem* _internal_mutable_cmd_drop_item();
  public:
  void unsafe_arena_set_allocated_cmd_drop_item(
      ::bestia::messages::DropItem* cmd_drop_item);
  ::bestia::messages::DropItem* unsafe_arena_release_cmd_drop_item();

  // .bestia.messages.PickupItem cmd_pickup_item = 102;
  bool has_cmd_pickup_item() const;
  private:
  bool _internal_has_cmd_pickup_item() const;
  public:
  void clear_cmd_pickup_item();
  const ::bestia::messages::PickupItem& cmd_pickup_item() const;
  ::bestia::messages::PickupItem* release_cmd_pickup_item();
  ::bestia::messages::PickupItem* mutable_cmd_pickup_item();
  void set_allocated_cmd_pickup_item(::bestia::messages::PickupItem* cmd_pickup_item);
  private:
  const ::bestia::messages::PickupItem& _internal_cmd_pickup_item() const;
  ::bestia::messages::PickupItem* _internal_mutable_cmd_pickup_item();
  public:
  void unsafe_arena_set_allocated_cmd_pickup_item(
      ::bestia::messages::PickupItem* cmd_pickup_item);
  ::bestia::messages::PickupItem* unsafe_arena_release_cmd_pickup_item();

  // .bestia.messages.PositionComponent comp_position = 300;
  bool has_comp_position() const;
  private:
  bool _internal_has_comp_position() const;
  public:
  void clear_comp_position();
  const ::bestia::messages::PositionComponent& comp_position() const;
  ::bestia::messages::PositionComponent* release_comp_position();
  ::bestia::messages::PositionComponent* mutable_comp_position();
  void set_allocated_comp_position(::bestia::messages::PositionComponent* comp_position);
  private:
  const ::bestia::messages::PositionComponent& _internal_comp_position() const;
  ::bestia::messages::PositionComponent* _internal_mutable_comp_position();
  public:
  void unsafe_arena_set_allocated_comp_position(
      ::bestia::messages::PositionComponent* comp_position);
  ::bestia::messages::PositionComponent* unsafe_arena_release_comp_position();

  // .bestia.messages.TemperatureComponent comp_temperature = 301;
  bool has_comp_temperature() const;
  private:
  bool _internal_has_comp_temperature() const;
  public:
  void clear_comp_temperature();
  const ::bestia::messages::TemperatureComponent& comp_temperature() const;
  ::bestia::messages::TemperatureComponent* release_comp_temperature();
  ::bestia::messages::TemperatureComponent* mutable_comp_temperature();
  void set_allocated_comp_temperature(::bestia::messages::TemperatureComponent* comp_temperature);
  private:
  const ::bestia::messages::TemperatureComponent& _internal_comp_temperature() const;
  ::bestia::messages::TemperatureComponent* _internal_mutable_comp_temperature();
  public:
  void unsafe_arena_set_allocated_comp_temperature(
      ::bestia::messages::TemperatureComponent* comp_temperature);
  ::bestia::messages::TemperatureComponent* unsafe_arena_release_comp_temperature();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:bestia.messages.Wrapper)
 private:
  class _Internal;
  void set_has_auth();
  void set_has_account_var_request();
  void set_has_account_var_response();
  void set_has_cmd_use_item();
  void set_has_cmd_drop_item();
  void set_has_cmd_pickup_item();
  void set_has_comp_position();
  void set_has_comp_temperature();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PayloadUnion {
    PayloadUnion() {}
    ::bestia::messages::Auth* auth_;
    ::bestia::messages::AccountVarRequest* account_var_request_;
    ::bestia::messages::AccountVarResponse* account_var_response_;
    ::bestia::messages::UseItem* cmd_use_item_;
    ::bestia::messages::DropItem* cmd_drop_item_;
    ::bestia::messages::PickupItem* cmd_pickup_item_;
    ::bestia::messages::PositionComponent* comp_position_;
    ::bestia::messages::TemperatureComponent* comp_temperature_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_default_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Wrapper

// .bestia.messages.Auth auth = 1;
inline bool Wrapper::_internal_has_auth() const {
  return payload_case() == kAuth;
}
inline bool Wrapper::has_auth() const {
  return _internal_has_auth();
}
inline void Wrapper::set_has_auth() {
  _oneof_case_[0] = kAuth;
}
inline ::bestia::messages::Auth* Wrapper::release_auth() {
  // @@protoc_insertion_point(field_release:bestia.messages.Wrapper.auth)
  if (_internal_has_auth()) {
    clear_has_payload();
      ::bestia::messages::Auth* temp = payload_.auth_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.auth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bestia::messages::Auth& Wrapper::_internal_auth() const {
  return _internal_has_auth()
      ? *payload_.auth_
      : *reinterpret_cast< ::bestia::messages::Auth*>(&::bestia::messages::_Auth_default_instance_);
}
inline const ::bestia::messages::Auth& Wrapper::auth() const {
  // @@protoc_insertion_point(field_get:bestia.messages.Wrapper.auth)
  return _internal_auth();
}
inline ::bestia::messages::Auth* Wrapper::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bestia.messages.Wrapper.auth)
  if (_internal_has_auth()) {
    clear_has_payload();
    ::bestia::messages::Auth* temp = payload_.auth_;
    payload_.auth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_auth(::bestia::messages::Auth* auth) {
  clear_payload();
  if (auth) {
    set_has_auth();
    payload_.auth_ = auth;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bestia.messages.Wrapper.auth)
}
inline ::bestia::messages::Auth* Wrapper::_internal_mutable_auth() {
  if (!_internal_has_auth()) {
    clear_payload();
    set_has_auth();
    payload_.auth_ = CreateMaybeMessage< ::bestia::messages::Auth >(GetArena());
  }
  return payload_.auth_;
}
inline ::bestia::messages::Auth* Wrapper::mutable_auth() {
  // @@protoc_insertion_point(field_mutable:bestia.messages.Wrapper.auth)
  return _internal_mutable_auth();
}

// .bestia.messages.AccountVarRequest account_var_request = 2;
inline bool Wrapper::_internal_has_account_var_request() const {
  return payload_case() == kAccountVarRequest;
}
inline bool Wrapper::has_account_var_request() const {
  return _internal_has_account_var_request();
}
inline void Wrapper::set_has_account_var_request() {
  _oneof_case_[0] = kAccountVarRequest;
}
inline ::bestia::messages::AccountVarRequest* Wrapper::release_account_var_request() {
  // @@protoc_insertion_point(field_release:bestia.messages.Wrapper.account_var_request)
  if (_internal_has_account_var_request()) {
    clear_has_payload();
      ::bestia::messages::AccountVarRequest* temp = payload_.account_var_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.account_var_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bestia::messages::AccountVarRequest& Wrapper::_internal_account_var_request() const {
  return _internal_has_account_var_request()
      ? *payload_.account_var_request_
      : *reinterpret_cast< ::bestia::messages::AccountVarRequest*>(&::bestia::messages::_AccountVarRequest_default_instance_);
}
inline const ::bestia::messages::AccountVarRequest& Wrapper::account_var_request() const {
  // @@protoc_insertion_point(field_get:bestia.messages.Wrapper.account_var_request)
  return _internal_account_var_request();
}
inline ::bestia::messages::AccountVarRequest* Wrapper::unsafe_arena_release_account_var_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bestia.messages.Wrapper.account_var_request)
  if (_internal_has_account_var_request()) {
    clear_has_payload();
    ::bestia::messages::AccountVarRequest* temp = payload_.account_var_request_;
    payload_.account_var_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_account_var_request(::bestia::messages::AccountVarRequest* account_var_request) {
  clear_payload();
  if (account_var_request) {
    set_has_account_var_request();
    payload_.account_var_request_ = account_var_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bestia.messages.Wrapper.account_var_request)
}
inline ::bestia::messages::AccountVarRequest* Wrapper::_internal_mutable_account_var_request() {
  if (!_internal_has_account_var_request()) {
    clear_payload();
    set_has_account_var_request();
    payload_.account_var_request_ = CreateMaybeMessage< ::bestia::messages::AccountVarRequest >(GetArena());
  }
  return payload_.account_var_request_;
}
inline ::bestia::messages::AccountVarRequest* Wrapper::mutable_account_var_request() {
  // @@protoc_insertion_point(field_mutable:bestia.messages.Wrapper.account_var_request)
  return _internal_mutable_account_var_request();
}

// .bestia.messages.AccountVarResponse account_var_response = 3;
inline bool Wrapper::_internal_has_account_var_response() const {
  return payload_case() == kAccountVarResponse;
}
inline bool Wrapper::has_account_var_response() const {
  return _internal_has_account_var_response();
}
inline void Wrapper::set_has_account_var_response() {
  _oneof_case_[0] = kAccountVarResponse;
}
inline ::bestia::messages::AccountVarResponse* Wrapper::release_account_var_response() {
  // @@protoc_insertion_point(field_release:bestia.messages.Wrapper.account_var_response)
  if (_internal_has_account_var_response()) {
    clear_has_payload();
      ::bestia::messages::AccountVarResponse* temp = payload_.account_var_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.account_var_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bestia::messages::AccountVarResponse& Wrapper::_internal_account_var_response() const {
  return _internal_has_account_var_response()
      ? *payload_.account_var_response_
      : *reinterpret_cast< ::bestia::messages::AccountVarResponse*>(&::bestia::messages::_AccountVarResponse_default_instance_);
}
inline const ::bestia::messages::AccountVarResponse& Wrapper::account_var_response() const {
  // @@protoc_insertion_point(field_get:bestia.messages.Wrapper.account_var_response)
  return _internal_account_var_response();
}
inline ::bestia::messages::AccountVarResponse* Wrapper::unsafe_arena_release_account_var_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bestia.messages.Wrapper.account_var_response)
  if (_internal_has_account_var_response()) {
    clear_has_payload();
    ::bestia::messages::AccountVarResponse* temp = payload_.account_var_response_;
    payload_.account_var_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_account_var_response(::bestia::messages::AccountVarResponse* account_var_response) {
  clear_payload();
  if (account_var_response) {
    set_has_account_var_response();
    payload_.account_var_response_ = account_var_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bestia.messages.Wrapper.account_var_response)
}
inline ::bestia::messages::AccountVarResponse* Wrapper::_internal_mutable_account_var_response() {
  if (!_internal_has_account_var_response()) {
    clear_payload();
    set_has_account_var_response();
    payload_.account_var_response_ = CreateMaybeMessage< ::bestia::messages::AccountVarResponse >(GetArena());
  }
  return payload_.account_var_response_;
}
inline ::bestia::messages::AccountVarResponse* Wrapper::mutable_account_var_response() {
  // @@protoc_insertion_point(field_mutable:bestia.messages.Wrapper.account_var_response)
  return _internal_mutable_account_var_response();
}

// .bestia.messages.UseItem cmd_use_item = 100;
inline bool Wrapper::_internal_has_cmd_use_item() const {
  return payload_case() == kCmdUseItem;
}
inline bool Wrapper::has_cmd_use_item() const {
  return _internal_has_cmd_use_item();
}
inline void Wrapper::set_has_cmd_use_item() {
  _oneof_case_[0] = kCmdUseItem;
}
inline ::bestia::messages::UseItem* Wrapper::release_cmd_use_item() {
  // @@protoc_insertion_point(field_release:bestia.messages.Wrapper.cmd_use_item)
  if (_internal_has_cmd_use_item()) {
    clear_has_payload();
      ::bestia::messages::UseItem* temp = payload_.cmd_use_item_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.cmd_use_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bestia::messages::UseItem& Wrapper::_internal_cmd_use_item() const {
  return _internal_has_cmd_use_item()
      ? *payload_.cmd_use_item_
      : *reinterpret_cast< ::bestia::messages::UseItem*>(&::bestia::messages::_UseItem_default_instance_);
}
inline const ::bestia::messages::UseItem& Wrapper::cmd_use_item() const {
  // @@protoc_insertion_point(field_get:bestia.messages.Wrapper.cmd_use_item)
  return _internal_cmd_use_item();
}
inline ::bestia::messages::UseItem* Wrapper::unsafe_arena_release_cmd_use_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bestia.messages.Wrapper.cmd_use_item)
  if (_internal_has_cmd_use_item()) {
    clear_has_payload();
    ::bestia::messages::UseItem* temp = payload_.cmd_use_item_;
    payload_.cmd_use_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_cmd_use_item(::bestia::messages::UseItem* cmd_use_item) {
  clear_payload();
  if (cmd_use_item) {
    set_has_cmd_use_item();
    payload_.cmd_use_item_ = cmd_use_item;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bestia.messages.Wrapper.cmd_use_item)
}
inline ::bestia::messages::UseItem* Wrapper::_internal_mutable_cmd_use_item() {
  if (!_internal_has_cmd_use_item()) {
    clear_payload();
    set_has_cmd_use_item();
    payload_.cmd_use_item_ = CreateMaybeMessage< ::bestia::messages::UseItem >(GetArena());
  }
  return payload_.cmd_use_item_;
}
inline ::bestia::messages::UseItem* Wrapper::mutable_cmd_use_item() {
  // @@protoc_insertion_point(field_mutable:bestia.messages.Wrapper.cmd_use_item)
  return _internal_mutable_cmd_use_item();
}

// .bestia.messages.DropItem cmd_drop_item = 101;
inline bool Wrapper::_internal_has_cmd_drop_item() const {
  return payload_case() == kCmdDropItem;
}
inline bool Wrapper::has_cmd_drop_item() const {
  return _internal_has_cmd_drop_item();
}
inline void Wrapper::set_has_cmd_drop_item() {
  _oneof_case_[0] = kCmdDropItem;
}
inline ::bestia::messages::DropItem* Wrapper::release_cmd_drop_item() {
  // @@protoc_insertion_point(field_release:bestia.messages.Wrapper.cmd_drop_item)
  if (_internal_has_cmd_drop_item()) {
    clear_has_payload();
      ::bestia::messages::DropItem* temp = payload_.cmd_drop_item_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.cmd_drop_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bestia::messages::DropItem& Wrapper::_internal_cmd_drop_item() const {
  return _internal_has_cmd_drop_item()
      ? *payload_.cmd_drop_item_
      : *reinterpret_cast< ::bestia::messages::DropItem*>(&::bestia::messages::_DropItem_default_instance_);
}
inline const ::bestia::messages::DropItem& Wrapper::cmd_drop_item() const {
  // @@protoc_insertion_point(field_get:bestia.messages.Wrapper.cmd_drop_item)
  return _internal_cmd_drop_item();
}
inline ::bestia::messages::DropItem* Wrapper::unsafe_arena_release_cmd_drop_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bestia.messages.Wrapper.cmd_drop_item)
  if (_internal_has_cmd_drop_item()) {
    clear_has_payload();
    ::bestia::messages::DropItem* temp = payload_.cmd_drop_item_;
    payload_.cmd_drop_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_cmd_drop_item(::bestia::messages::DropItem* cmd_drop_item) {
  clear_payload();
  if (cmd_drop_item) {
    set_has_cmd_drop_item();
    payload_.cmd_drop_item_ = cmd_drop_item;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bestia.messages.Wrapper.cmd_drop_item)
}
inline ::bestia::messages::DropItem* Wrapper::_internal_mutable_cmd_drop_item() {
  if (!_internal_has_cmd_drop_item()) {
    clear_payload();
    set_has_cmd_drop_item();
    payload_.cmd_drop_item_ = CreateMaybeMessage< ::bestia::messages::DropItem >(GetArena());
  }
  return payload_.cmd_drop_item_;
}
inline ::bestia::messages::DropItem* Wrapper::mutable_cmd_drop_item() {
  // @@protoc_insertion_point(field_mutable:bestia.messages.Wrapper.cmd_drop_item)
  return _internal_mutable_cmd_drop_item();
}

// .bestia.messages.PickupItem cmd_pickup_item = 102;
inline bool Wrapper::_internal_has_cmd_pickup_item() const {
  return payload_case() == kCmdPickupItem;
}
inline bool Wrapper::has_cmd_pickup_item() const {
  return _internal_has_cmd_pickup_item();
}
inline void Wrapper::set_has_cmd_pickup_item() {
  _oneof_case_[0] = kCmdPickupItem;
}
inline ::bestia::messages::PickupItem* Wrapper::release_cmd_pickup_item() {
  // @@protoc_insertion_point(field_release:bestia.messages.Wrapper.cmd_pickup_item)
  if (_internal_has_cmd_pickup_item()) {
    clear_has_payload();
      ::bestia::messages::PickupItem* temp = payload_.cmd_pickup_item_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.cmd_pickup_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bestia::messages::PickupItem& Wrapper::_internal_cmd_pickup_item() const {
  return _internal_has_cmd_pickup_item()
      ? *payload_.cmd_pickup_item_
      : *reinterpret_cast< ::bestia::messages::PickupItem*>(&::bestia::messages::_PickupItem_default_instance_);
}
inline const ::bestia::messages::PickupItem& Wrapper::cmd_pickup_item() const {
  // @@protoc_insertion_point(field_get:bestia.messages.Wrapper.cmd_pickup_item)
  return _internal_cmd_pickup_item();
}
inline ::bestia::messages::PickupItem* Wrapper::unsafe_arena_release_cmd_pickup_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bestia.messages.Wrapper.cmd_pickup_item)
  if (_internal_has_cmd_pickup_item()) {
    clear_has_payload();
    ::bestia::messages::PickupItem* temp = payload_.cmd_pickup_item_;
    payload_.cmd_pickup_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_cmd_pickup_item(::bestia::messages::PickupItem* cmd_pickup_item) {
  clear_payload();
  if (cmd_pickup_item) {
    set_has_cmd_pickup_item();
    payload_.cmd_pickup_item_ = cmd_pickup_item;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bestia.messages.Wrapper.cmd_pickup_item)
}
inline ::bestia::messages::PickupItem* Wrapper::_internal_mutable_cmd_pickup_item() {
  if (!_internal_has_cmd_pickup_item()) {
    clear_payload();
    set_has_cmd_pickup_item();
    payload_.cmd_pickup_item_ = CreateMaybeMessage< ::bestia::messages::PickupItem >(GetArena());
  }
  return payload_.cmd_pickup_item_;
}
inline ::bestia::messages::PickupItem* Wrapper::mutable_cmd_pickup_item() {
  // @@protoc_insertion_point(field_mutable:bestia.messages.Wrapper.cmd_pickup_item)
  return _internal_mutable_cmd_pickup_item();
}

// .bestia.messages.PositionComponent comp_position = 300;
inline bool Wrapper::_internal_has_comp_position() const {
  return payload_case() == kCompPosition;
}
inline bool Wrapper::has_comp_position() const {
  return _internal_has_comp_position();
}
inline void Wrapper::set_has_comp_position() {
  _oneof_case_[0] = kCompPosition;
}
inline ::bestia::messages::PositionComponent* Wrapper::release_comp_position() {
  // @@protoc_insertion_point(field_release:bestia.messages.Wrapper.comp_position)
  if (_internal_has_comp_position()) {
    clear_has_payload();
      ::bestia::messages::PositionComponent* temp = payload_.comp_position_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.comp_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bestia::messages::PositionComponent& Wrapper::_internal_comp_position() const {
  return _internal_has_comp_position()
      ? *payload_.comp_position_
      : *reinterpret_cast< ::bestia::messages::PositionComponent*>(&::bestia::messages::_PositionComponent_default_instance_);
}
inline const ::bestia::messages::PositionComponent& Wrapper::comp_position() const {
  // @@protoc_insertion_point(field_get:bestia.messages.Wrapper.comp_position)
  return _internal_comp_position();
}
inline ::bestia::messages::PositionComponent* Wrapper::unsafe_arena_release_comp_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bestia.messages.Wrapper.comp_position)
  if (_internal_has_comp_position()) {
    clear_has_payload();
    ::bestia::messages::PositionComponent* temp = payload_.comp_position_;
    payload_.comp_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_comp_position(::bestia::messages::PositionComponent* comp_position) {
  clear_payload();
  if (comp_position) {
    set_has_comp_position();
    payload_.comp_position_ = comp_position;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bestia.messages.Wrapper.comp_position)
}
inline ::bestia::messages::PositionComponent* Wrapper::_internal_mutable_comp_position() {
  if (!_internal_has_comp_position()) {
    clear_payload();
    set_has_comp_position();
    payload_.comp_position_ = CreateMaybeMessage< ::bestia::messages::PositionComponent >(GetArena());
  }
  return payload_.comp_position_;
}
inline ::bestia::messages::PositionComponent* Wrapper::mutable_comp_position() {
  // @@protoc_insertion_point(field_mutable:bestia.messages.Wrapper.comp_position)
  return _internal_mutable_comp_position();
}

// .bestia.messages.TemperatureComponent comp_temperature = 301;
inline bool Wrapper::_internal_has_comp_temperature() const {
  return payload_case() == kCompTemperature;
}
inline bool Wrapper::has_comp_temperature() const {
  return _internal_has_comp_temperature();
}
inline void Wrapper::set_has_comp_temperature() {
  _oneof_case_[0] = kCompTemperature;
}
inline ::bestia::messages::TemperatureComponent* Wrapper::release_comp_temperature() {
  // @@protoc_insertion_point(field_release:bestia.messages.Wrapper.comp_temperature)
  if (_internal_has_comp_temperature()) {
    clear_has_payload();
      ::bestia::messages::TemperatureComponent* temp = payload_.comp_temperature_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.comp_temperature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bestia::messages::TemperatureComponent& Wrapper::_internal_comp_temperature() const {
  return _internal_has_comp_temperature()
      ? *payload_.comp_temperature_
      : *reinterpret_cast< ::bestia::messages::TemperatureComponent*>(&::bestia::messages::_TemperatureComponent_default_instance_);
}
inline const ::bestia::messages::TemperatureComponent& Wrapper::comp_temperature() const {
  // @@protoc_insertion_point(field_get:bestia.messages.Wrapper.comp_temperature)
  return _internal_comp_temperature();
}
inline ::bestia::messages::TemperatureComponent* Wrapper::unsafe_arena_release_comp_temperature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bestia.messages.Wrapper.comp_temperature)
  if (_internal_has_comp_temperature()) {
    clear_has_payload();
    ::bestia::messages::TemperatureComponent* temp = payload_.comp_temperature_;
    payload_.comp_temperature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_comp_temperature(::bestia::messages::TemperatureComponent* comp_temperature) {
  clear_payload();
  if (comp_temperature) {
    set_has_comp_temperature();
    payload_.comp_temperature_ = comp_temperature;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bestia.messages.Wrapper.comp_temperature)
}
inline ::bestia::messages::TemperatureComponent* Wrapper::_internal_mutable_comp_temperature() {
  if (!_internal_has_comp_temperature()) {
    clear_payload();
    set_has_comp_temperature();
    payload_.comp_temperature_ = CreateMaybeMessage< ::bestia::messages::TemperatureComponent >(GetArena());
  }
  return payload_.comp_temperature_;
}
inline ::bestia::messages::TemperatureComponent* Wrapper::mutable_comp_temperature() {
  // @@protoc_insertion_point(field_mutable:bestia.messages.Wrapper.comp_temperature)
  return _internal_mutable_comp_temperature();
}

inline bool Wrapper::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Wrapper::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Wrapper::PayloadCase Wrapper::payload_case() const {
  return Wrapper::PayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace messages
}  // namespace bestia

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_default_2eproto
